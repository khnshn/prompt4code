[{"role": "system", "content": "You are a helpful assistant that generates python code per request. Your output only includes executable source code. Your output does not include any sort of explanation or description."}, {"role": "user", "content": "Write a simulation program in python using simpy with the following specifications: a Module as Event Latency example\n\nCovers:\n\n- Resources: Store\n\nScenario:\n  This example shows how to separate the time delay of events between\n  processes from the processes themselves.\n\nWhen Useful:\n  When modeling physical things such as cables, RF propagation, etc.  it\n  better encapsulation to keep this propagation mechanism outside of the\n  sending and receiving processes.\n\n  Can also be used to interconnect processes sending messages\n\nExample by:\n  Keith Smith with a Class that This class represents the propagation through a cable. with a Function that A process which randomly generates messages. with a Function that A process which consumes messages.. Output executable code with no comments and no explanations."}, {"role": "assistant", "content": "\nimport simpy\n\n\nSIM_DURATION = 100\n\n\nclass Cable(object):\n    \n\n    def __init__(self, env, delay):\n        self.env = env\n        self.delay = delay\n        self.store = simpy.Store(env)\n\n    def latency(self, value):\n        yield self.env.timeout(self.delay)\n        self.store.put(value)\n\n    def put(self, value):\n        self.env.process(self.latency(value))\n\n    def get(self):\n        return self.store.get()\n\n\ndef sender(env, cable):\n    \n    while True:\n        \n        yield env.timeout(5)\n        cable.put(\"Sender sent this at %d\" % env.now)\n\n\ndef receiver(env, cable):\n    \n    while True:\n        \n        msg = yield cable.get()\n        print(\"Received this at %d while %s\" % (env.now, msg))\n\n\n\nprint(\"Event Latency\")\nenv = simpy.Environment()\n\ncable = Cable(env, 10)\nenv.process(sender(env, cable))\nenv.process(receiver(env, cable))\n\nenv.run(until=SIM_DURATION)\n"}, {"role": "user", "content": "Write a simulation program in python using simpy with the following specifications: a Module as Carwash example.\n\nCovers:\n\n- Waiting for other processes\n- Resources: Resource\n\nScenario:\n  A carwash has a limited number of washing machines and defines\n  a washing processes that takes some (random) time.\n\n  Car processes arrive at the carwash at a random time. If one washing\n  machine is available, they start the washing process and wait for it\n  to finish. If not, they wait until they an use one. with a Class that A carwash has a limited number of machines (``NUM_MACHINES``) to\nclean cars in parallel.\n\nCars have to request one of the machines. When they got one, they\ncan start the washing processes and wait for it to finish (which\ntakes ``washtime`` minutes). with a Function that The car process (each car has a ``name``) arrives at the carwash\n(``cw``) and requests a cleaning machine.\n\nIt then starts the washing process, waits for it to finish and\nleaves to never come back ... with a Function that Create a carwash, a number of initial cars and keep creating cars\napprox. every ``t_inter`` minutes.. Output executable code with no comments and no explanations."}, {"role": "assistant", "content": "\nimport random\n\nimport simpy\n\n\nRANDOM_SEED = 42\nNUM_MACHINES = 2  \nWASHTIME = 5  \nT_INTER = 7  \nSIM_TIME = 20  \n\n\nclass Carwash(object):\n    \n\n    def __init__(self, env, num_machines, washtime):\n        self.env = env\n        self.machine = simpy.Resource(env, num_machines)\n        self.washtime = washtime\n\n    def wash(self, car):\n        \n        yield self.env.timeout(WASHTIME)\n        print(\"Carwash removed %d%% of %s's dirt.\" % (random.randint(50, 99), car))\n\n\ndef car(env, name, cw):\n    \n    print(\"%s arrives at the carwash at %.2f.\" % (name, env.now))\n    with cw.machine.request() as request:\n        yield request\n\n        print(\"%s enters the carwash at %.2f.\" % (name, env.now))\n        yield env.process(cw.wash(name))\n\n        print(\"%s leaves the carwash at %.2f.\" % (name, env.now))\n\n\ndef setup(env, num_machines, washtime, t_inter):\n    \n    \n    carwash = Carwash(env, num_machines, washtime)\n\n    \n    for i in range(4):\n        env.process(car(env, \"Car %d\" % i, carwash))\n\n    \n    while True:\n        yield env.timeout(random.randint(t_inter - 2, t_inter + 2))\n        i += 1\n        env.process(car(env, \"Car %d\" % i, carwash))\n\n\n\nprint(\"Carwash\")\nprint(\"Check out http://youtu.be/fXXmeP9TvBg while simulating ... ;-)\")\nrandom.seed(RANDOM_SEED)  \n\n\nenv = simpy.Environment()\nenv.process(setup(env, NUM_MACHINES, WASHTIME, T_INTER))\n\n\nenv.run(until=SIM_TIME)\n"}, {"role": "user", "content": "Write a simulation program in python using simpy with the following specifications: a Module as Bank renege example\n\nCovers:\n\n- Resources: Resource\n- Condition events\n\nScenario:\n  A counter with a random service time and customers who renege. Based on the\n  program bank08.py from TheBank tutorial of SimPy 2. (KGM) with a Function that Source generates customers randomly with a Function that Customer arrives, is served and leaves.. Output executable code with no comments and no explanations."}, {"role": "assistant", "content": "\nimport random\n\nimport simpy\n\n\nRANDOM_SEED = 42\nNEW_CUSTOMERS = 5  \nINTERVAL_CUSTOMERS = 10.0  \nMIN_PATIENCE = 1  \nMAX_PATIENCE = 3  \n\n\ndef source(env, number, interval, counter):\n    \n    for i in range(number):\n        c = customer(env, \"Customer%02d\" % i, counter, time_in_bank=12.0)\n        env.process(c)\n        t = random.expovariate(1.0 / interval)\n        yield env.timeout(t)\n\n\ndef customer(env, name, counter, time_in_bank):\n    \n    arrive = env.now\n    print(\"%7.4f %s: Here I am\" % (arrive, name))\n\n    with counter.request() as req:\n        patience = random.uniform(MIN_PATIENCE, MAX_PATIENCE)\n        \n        results = yield req | env.timeout(patience)\n\n        wait = env.now - arrive\n\n        if req in results:\n            \n            print(\"%7.4f %s: Waited %6.3f\" % (env.now, name, wait))\n\n            tib = random.expovariate(1.0 / time_in_bank)\n            yield env.timeout(tib)\n            print(\"%7.4f %s: Finished\" % (env.now, name))\n\n        else:\n            \n            print(\"%7.4f %s: RENEGED after %6.3f\" % (env.now, name, wait))\n\n\n\nprint(\"Bank renege\")\nrandom.seed(RANDOM_SEED)\nenv = simpy.Environment()\n\n\ncounter = simpy.Resource(env, capacity=1)\nenv.process(source(env, NEW_CUSTOMERS, INTERVAL_CUSTOMERS, counter))\nenv.run()\n"}, {"role": "user", "content": "Write a simulation program in python using simpy with the following specifications: a Module as Gas Station Refueling example\n\nCovers:\n\n- Resources: Resource\n- Resources: Container\n- Waiting for other processes\n\nScenario:\n  A gas station has a limited number of gas pumps that share a common\n  fuel reservoir. Cars randomly arrive at the gas station, request one\n  of the fuel pumps and start refueling from that reservoir.\n\n  A gas station control process observes the gas station's fuel level\n  and calls a tank truck for refueling if the station's level drops\n  below a threshold. with a Function that A car arrives at the gas station for refueling.\n\nIt requests one of the gas station's fuel pumps and tries to get the\ndesired amount of gas from it. If the stations reservoir is\ndepleted, the car has to wait for the tank truck to arrive. with a Function that Periodically check the level of the *fuel_pump* and call the tank\ntruck if the level falls below a threshold. with a Function that Arrives at the gas station after a certain delay and refuels it. with a Function that Generate new cars that arrive at the gas station.. Output executable code with no comments and no explanations."}, {"role": "assistant", "content": "\nimport itertools\nimport random\n\nimport simpy\n\n\nRANDOM_SEED = 42\nGAS_STATION_SIZE = 200  \nTHRESHOLD = 10  \nFUEL_TANK_SIZE = 50  \nFUEL_TANK_LEVEL = [5, 25]  \nREFUELING_SPEED = 2  \nTANK_TRUCK_TIME = 300  \nT_INTER = [30, 300]  \nSIM_TIME = 1000  \n\n\ndef car(name, env, gas_station, fuel_pump):\n    \n    fuel_tank_level = random.randint(*FUEL_TANK_LEVEL)\n    print(\"%s arriving at gas station at %.1f\" % (name, env.now))\n    with gas_station.request() as req:\n        start = env.now\n        \n        yield req\n\n        \n        liters_required = FUEL_TANK_SIZE - fuel_tank_level\n        yield fuel_pump.get(liters_required)\n\n        \n        yield env.timeout(liters_required / REFUELING_SPEED)\n\n        print(\"%s finished refueling in %.1f seconds.\" % (name, env.now - start))\n\n\ndef gas_station_control(env, fuel_pump):\n    \n    while True:\n        if fuel_pump.level / fuel_pump.capacity * 100 < THRESHOLD:\n            \n            print(\"Calling tank truck at %d\" % env.now)\n            \n            yield env.process(tank_truck(env, fuel_pump))\n\n        yield env.timeout(10)  \n\n\ndef tank_truck(env, fuel_pump):\n    \n    yield env.timeout(TANK_TRUCK_TIME)\n    print(\"Tank truck arriving at time %d\" % env.now)\n    ammount = fuel_pump.capacity - fuel_pump.level\n    print(\"Tank truck refuelling %.1f liters.\" % ammount)\n    yield fuel_pump.put(ammount)\n\n\ndef car_generator(env, gas_station, fuel_pump):\n    \n    for i in itertools.count():\n        yield env.timeout(random.randint(*T_INTER))\n        env.process(car(\"Car %d\" % i, env, gas_station, fuel_pump))\n\n\n\nprint(\"Gas Station refuelling\")\nrandom.seed(RANDOM_SEED)\n\n\nenv = simpy.Environment()\ngas_station = simpy.Resource(env, 2)\nfuel_pump = simpy.Container(env, GAS_STATION_SIZE, init=GAS_STATION_SIZE)\nenv.process(gas_station_control(env, fuel_pump))\nenv.process(car_generator(env, gas_station, fuel_pump))\n\n\nenv.run(until=SIM_TIME)\n"}, {"role": "user", "content": "Write a simulation program in python using simpy with the following specifications: a Module as Process communication example\n\nCovers:\n\n- Resources: Store\n\nScenario:\n  This example shows how to interconnect simulation model elements\n  together using :class:`~simpy.resources.store.Store` for one-to-one,\n  and many-to-one asynchronous processes. For one-to-many a simple\n  BroadCastPipe class is constructed from Store.\n\nWhen Useful:\n  When a consumer process does not always wait on a generating process\n  and these processes run asynchronously. This example shows how to\n  create a buffer and also tell is the consumer process was late\n  yielding to the event from a generating process.\n\n  This is also useful when some information needs to be broadcast to\n  many receiving processes\n\n  Finally, using pipes can simplify how processes are interconnected to\n  each other in a simulation model.\n\nExample By:\n  Keith Smith with a Class that A Broadcast pipe that allows one process to send messages to many.\n\nThis construct is useful when message consumers are running at\ndifferent rates than message generators and provides an event\nbuffering to the consuming processes.\n\nThe parameters are used to create a new\n:class:`~simpy.resources.store.Store` instance each time\n:meth:`get_output_conn()` is called. with a Function that A process which randomly generates messages. with a Function that A process which consumes messages.. Output executable code with no comments and no explanations."}, {"role": "assistant", "content": "\nimport random\n\nimport simpy\n\n\nRANDOM_SEED = 42\nSIM_TIME = 100\n\n\nclass BroadcastPipe(object):\n    \n\n    def __init__(self, env, capacity=simpy.core.Infinity):\n        self.env = env\n        self.capacity = capacity\n        self.pipes = []\n\n    def put(self, value):\n        \n        if not self.pipes:\n            raise RuntimeError(\"There are no output pipes.\")\n        events = [store.put(value) for store in self.pipes]\n        return self.env.all_of(events)  \n\n    def get_output_conn(self):\n        \n        pipe = simpy.Store(self.env, capacity=self.capacity)\n        self.pipes.append(pipe)\n        return pipe\n\n\ndef message_generator(name, env, out_pipe):\n    \n    while True:\n        \n        yield env.timeout(random.randint(6, 10))\n\n        \n        \n        \n        \n        \n        \n        \n        msg = (env.now, \"%s says hello at %d\" % (name, env.now))\n        out_pipe.put(msg)\n\n\ndef message_consumer(name, env, in_pipe):\n    \n    while True:\n        \n        msg = yield in_pipe.get()\n\n        if msg[0] < env.now:\n            \n            \n            \n            \n            print(\n                \"LATE Getting Message: at time %d: %s received message: %s\"\n                % (env.now, name, msg[1])\n            )\n\n        else:\n            \n            print(\"at time %d: %s received message: %s.\" % (env.now, name, msg[1]))\n\n        \n        yield env.timeout(random.randint(4, 8))\n\n\n\nprint(\"Process communication\")\nrandom.seed(RANDOM_SEED)\nenv = simpy.Environment()\n\n\npipe = simpy.Store(env)\nenv.process(message_generator(\"Generator A\", env, pipe))\nenv.process(message_consumer(\"Consumer A\", env, pipe))\n\nprint(\"\\nOne-to-one pipe communication\\n\")\nenv.run(until=SIM_TIME)\n\n\n\nenv = simpy.Environment()\nbc_pipe = BroadcastPipe(env)\n\nenv.process(message_generator(\"Generator A\", env, bc_pipe))\nenv.process(message_consumer(\"Consumer A\", env, bc_pipe.get_output_conn()))\nenv.process(message_consumer(\"Consumer B\", env, bc_pipe.get_output_conn()))\n\nprint(\"\\nOne-to-many pipe communication\\n\")\nenv.run(until=SIM_TIME)\n"}, {"role": "user", "content": "Write a simulation program in python using simpy with the following specifications: a Module as Machine shop example\n\nCovers:\n\n- Interrupts\n- Resources: PreemptiveResource\n\nScenario:\n  A workshop has *n* identical machines. A stream of jobs (enough to\n  keep the machines busy) arrives. Each machine breaks down\n  periodically. Repairs are carried out by one repairman. The repairman\n  has other, less important tasks to perform, too. Broken machines\n  preempt theses tasks. The repairman continues them when he is done\n  with the machine repair. The workshop works continuously. with a Function that Return actual processing time for a concrete part. with a Function that Return time until next failure for a machine. with a Class that A machine produces parts and my get broken every now and then.\n\nIf it breaks, it requests a *repairman* and continues the production\nafter the it is repaired.\n\nA machine has a *name* and a numberof *parts_made* thus far. with a Function that The repairman's other (unimportant) job.. Output executable code with no comments and no explanations."}, {"role": "assistant", "content": "\nimport random\n\nimport simpy\n\n\nRANDOM_SEED = 42\nPT_MEAN = 10.0  \nPT_SIGMA = 2.0  \nMTTF = 300.0  \nBREAK_MEAN = 1 / MTTF  \nREPAIR_TIME = 30.0  \nJOB_DURATION = 30.0  \nNUM_MACHINES = 10  \nWEEKS = 4  \nSIM_TIME = WEEKS * 7 * 24 * 60  \n\n\ndef time_per_part():\n    \n    return random.normalvariate(PT_MEAN, PT_SIGMA)\n\n\ndef time_to_failure():\n    \n    return random.expovariate(BREAK_MEAN)\n\n\nclass Machine(object):\n    \n\n    def __init__(self, env, name, repairman):\n        self.env = env\n        self.name = name\n        self.parts_made = 0\n        self.broken = False\n\n        \n        self.process = env.process(self.working(repairman))\n        env.process(self.break_machine())\n\n    def working(self, repairman):\n        \n        while True:\n            \n            done_in = time_per_part()\n            while done_in:\n                try:\n                    \n                    start = self.env.now\n                    yield self.env.timeout(done_in)\n                    done_in = 0  \n\n                except simpy.Interrupt:\n                    self.broken = True\n                    done_in -= self.env.now - start  \n\n                    \n                    with repairman.request(priority=1) as req:\n                        yield req\n                        yield self.env.timeout(REPAIR_TIME)\n\n                    self.broken = False\n\n            \n            self.parts_made += 1\n\n    def break_machine(self):\n        \n        while True:\n            yield self.env.timeout(time_to_failure())\n            if not self.broken:\n                \n                self.process.interrupt()\n\n\ndef other_jobs(env, repairman):\n    \n    while True:\n        \n        done_in = JOB_DURATION\n        while done_in:\n            \n            \n            with repairman.request(priority=2) as req:\n                yield req\n                try:\n                    start = env.now\n                    yield env.timeout(done_in)\n                    done_in = 0\n                except simpy.Interrupt:\n                    done_in -= env.now - start\n\n\n\nprint(\"Machine shop\")\nrandom.seed(RANDOM_SEED)  \n\n\nenv = simpy.Environment()\nrepairman = simpy.PreemptiveResource(env, capacity=1)\nmachines = [Machine(env, \"Machine %d\" % i, repairman) for i in range(NUM_MACHINES)]\nenv.process(other_jobs(env, repairman))\n\n\nenv.run(until=SIM_TIME)\n\n\nprint(\"Machine shop results after %s weeks\" % WEEKS)\nfor machine in machines:\n    print(\"%s made %d parts.\" % (machine.name, machine.parts_made))\n"}, {"role": "user", "content": "Write a simulation program in python using simpy with the following specifications: a Module as Movie renege example\n\nCovers:\n\n- Resources: Resource\n- Condition events\n- Shared events\n\nScenario:\n  A movie theatre has one ticket counter selling tickets for three\n  movies (next show only). When a movie is sold out, all people waiting\n  to buy tickets for that movie renege (leave queue). with a Function that A moviegoer tries to by a number of tickets (*num_tickets*) for\na certain *movie* in a *theater*.\n\nIf the movie becomes sold out, she leaves the theater. If she gets\nto the counter, she tries to buy a number of tickets. If not enough\ntickets are left, she argues with the teller and leaves.\n\nIf at most one ticket is left after the moviegoer bought her\ntickets, the *sold out* event for this movie is triggered causing\nall remaining moviegoers to leave. with a Function that Create new *moviegoers* until the sim time reaches 120.. Output executable code with no comments and no explanations."}, {"role": "assistant", "content": "\nimport collections\nimport random\n\nimport simpy\n\n\nRANDOM_SEED = 42\nTICKETS = 50  \nSIM_TIME = 120  \n\n\ndef moviegoer(env, movie, num_tickets, theater):\n    \n    with theater.counter.request() as my_turn:\n        \n        result = yield my_turn | theater.sold_out[movie]\n\n        \n        if my_turn not in result:\n            theater.num_renegers[movie] += 1\n            return\n\n        \n        if theater.available[movie] < num_tickets:\n            \n            yield env.timeout(0.5)\n            return\n\n        \n        theater.available[movie] -= num_tickets\n        if theater.available[movie] < 2:\n            \n            theater.sold_out[movie].succeed()\n            theater.when_sold_out[movie] = env.now\n            theater.available[movie] = 0\n        yield env.timeout(1)\n\n\ndef customer_arrivals(env, theater):\n    \n    while True:\n        yield env.timeout(random.expovariate(1 / 0.5))\n\n        movie = random.choice(theater.movies)\n        num_tickets = random.randint(1, 6)\n        if theater.available[movie]:\n            env.process(moviegoer(env, movie, num_tickets, theater))\n\n\nTheater = collections.namedtuple(\n    \"Theater\", \"counter, movies, available, \" \"sold_out, when_sold_out, \" \"num_renegers\"\n)\n\n\n\nprint(\"Movie renege\")\nrandom.seed(RANDOM_SEED)\nenv = simpy.Environment()\n\n\ncounter = simpy.Resource(env, capacity=1)\nmovies = [\"Python Unchained\", \"Kill Process\", \"Pulp Implementation\"]\navailable = {movie: TICKETS for movie in movies}\nsold_out = {movie: env.event() for movie in movies}\nwhen_sold_out = {movie: None for movie in movies}\nnum_renegers = {movie: 0 for movie in movies}\ntheater = Theater(counter, movies, available, sold_out, when_sold_out, num_renegers)\n\n\nenv.process(customer_arrivals(env, theater))\nenv.run(until=SIM_TIME)\n\n\nfor movie in movies:\n    if theater.sold_out[movie]:\n        print(\n            'Movie \"%s\" sold out %.1f minutes after ticket counter '\n            \"opening.\" % (movie, theater.when_sold_out[movie])\n        )\n        print(\n            \"  Number of people leaving queue when film sold out: %s\"\n            % theater.num_renegers[movie]\n        )\n"}, {"role": "user", "content": "write a python program using simpy that simulates teachers activities during a day. teachers will receive notifications on their smartphone every 2 hours. then depending on their situation they either respond to the notification or ignore it. estimate the response rate to such notfication. run such program for 50 teachers. Output executable code with no comments and no explanations."}]